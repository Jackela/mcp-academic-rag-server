"""
Milvus文档存储实现

该模块提供基于Milvus向量数据库的文档存储功能，支持向量存储、检索和元数据管理。
Milvus是专为向量相似性搜索和AI应用设计的高性能向量数据库。
"""

import logging
import json
import uuid
from typing import Dict, List, Any, Optional, Union
from datetime import datetime

try:
    from pymilvus import (
        connections, Collection, CollectionSchema, FieldSchema, DataType,
        utility, db, MilvusException
    )
    MILVUS_AVAILABLE = True
except ImportError:
    MILVUS_AVAILABLE = False
    print("警告: pymilvus未安装，Milvus功能不可用。请使用 'pip install pymilvus' 安装。")

from haystack.schema import Document as HaystackDocument

logger = logging.getLogger(__name__)


class MilvusDocumentStore:
    """
    基于Milvus的文档存储类
    
    提供向量存储、检索和元数据管理功能，支持高性能的相似性搜索。
    """
    
    def __init__(self, config: Dict[str, Any] = None):
        """
        初始化Milvus文档存储
        
        Args:
            config: Milvus配置字典
        """
        if not MILVUS_AVAILABLE:
            raise ImportError("pymilvus包未安装，无法使用MilvusDocumentStore")
        
        self.config = config or {}
        self.logger = logging.getLogger("milvus_document_store")
        
        # Milvus连接配置
        self.host = self.config.get("host", "localhost")
        self.port = self.config.get("port", 19530)
        self.user = self.config.get("user", "")
        self.password = self.config.get("password", "")
        self.db_name = self.config.get("database", "default")
        
        # 集合配置
        self.collection_name = self.config.get("collection_name", "document_vectors")
        self.vector_dimension = self.config.get("vector_dimension", 384)  # all-MiniLM-L6-v2的维度
        self.index_type = self.config.get("index_type", "IVF_FLAT")
        self.metric_type = self.config.get("metric_type", "COSINE")
        self.index_params = self.config.get("index_params", {"nlist": 128})\n        \n        # 搜索配置\n        self.search_params = self.config.get("search_params", {"nprobe": 10})\n        \n        # 连接状态\n        self.connection_alias = f"milvus_{uuid.uuid4().hex[:8]}"\n        self.collection = None\n        self.connected = False\n        \n        # 连接到Milvus\n        self._connect()\n        \n        # 创建或获取集合\n        self._initialize_collection()\n    \n    def _connect(self) -> None:\n        \"\"\"连接到Milvus服务器\"\"\"\n        try:\n            # 创建连接\n            connections.connect(\n                alias=self.connection_alias,\n                host=self.host,\n                port=self.port,\n                user=self.user,\n                password=self.password,\n                db_name=self.db_name\n            )\n            \n            self.connected = True\n            self.logger.info(f\"成功连接到Milvus服务器 {self.host}:{self.port}\")\n            \n        except Exception as e:\n            self.logger.error(f\"连接Milvus失败: {str(e)}\")\n            raise\n    \n    def _initialize_collection(self) -> None:\n        \"\"\"初始化或创建集合\"\"\"\n        try:\n            # 检查集合是否存在\n            if utility.has_collection(self.collection_name, using=self.connection_alias):\n                self.logger.info(f\"集合 '{self.collection_name}' 已存在，正在加载...\")\n                self.collection = Collection(self.collection_name, using=self.connection_alias)\n                self.collection.load()\n            else:\n                self.logger.info(f\"创建新集合 '{self.collection_name}'...\")\n                self._create_collection()\n            \n            self.logger.info(f\"集合 '{self.collection_name}' 初始化完成\")\n            \n        except Exception as e:\n            self.logger.error(f\"初始化集合失败: {str(e)}\")\n            raise\n    \n    def _create_collection(self) -> None:\n        \"\"\"创建Milvus集合\"\"\"\n        # 定义字段架构\n        fields = [\n            FieldSchema(\n                name=\"id\",\n                dtype=DataType.VARCHAR,\n                is_primary=True,\n                max_length=255,\n                description=\"文档唯一ID\"\n            ),\n            FieldSchema(\n                name=\"content\",\n                dtype=DataType.VARCHAR,\n                max_length=65535,\n                description=\"文档内容\"\n            ),\n            FieldSchema(\n                name=\"embedding\",\n                dtype=DataType.FLOAT_VECTOR,\n                dim=self.vector_dimension,\n                description=\"文档向量嵌入\"\n            ),\n            FieldSchema(\n                name=\"metadata\",\n                dtype=DataType.VARCHAR,\n                max_length=65535,\n                description=\"文档元数据(JSON格式)\"\n            ),\n            FieldSchema(\n                name=\"created_at\",\n                dtype=DataType.VARCHAR,\n                max_length=50,\n                description=\"创建时间\"\n            )\n        ]\n        \n        # 创建集合架构\n        schema = CollectionSchema(\n            fields=fields,\n            description=\"学术文档向量集合\",\n            enable_dynamic_field=True\n        )\n        \n        # 创建集合\n        self.collection = Collection(\n            name=self.collection_name,\n            schema=schema,\n            using=self.connection_alias\n        )\n        \n        # 创建索引\n        self._create_index()\n        \n        # 加载集合\n        self.collection.load()\n        \n        self.logger.info(f\"成功创建集合 '{self.collection_name}'\")\n    \n    def _create_index(self) -> None:\n        \"\"\"为向量字段创建索引\"\"\"\n        try:\n            index_params = {\n                \"index_type\": self.index_type,\n                \"metric_type\": self.metric_type,\n                \"params\": self.index_params\n            }\n            \n            self.collection.create_index(\n                field_name=\"embedding\",\n                index_params=index_params\n            )\n            \n            self.logger.info(f\"成功创建索引，类型: {self.index_type}，度量: {self.metric_type}\")\n            \n        except Exception as e:\n            self.logger.error(f\"创建索引失败: {str(e)}\")\n            raise\n    \n    def add_document(self, document: HaystackDocument) -> bool:\n        \"\"\"添加单个文档到存储\"\"\"\n        return self.add_documents([document])\n    \n    def add_documents(self, documents: List[HaystackDocument]) -> bool:\n        \"\"\"\n        批量添加文档到Milvus存储\n        \n        Args:\n            documents: Haystack文档列表\n            \n        Returns:\n            是否添加成功\n        \"\"\"\n        if not documents:\n            return True\n        \n        try:\n            # 准备数据\n            ids = []\n            contents = []\n            embeddings = []\n            metadatas = []\n            created_ats = []\n            \n            current_time = datetime.now().isoformat()\n            \n            for doc in documents:\n                # 文档ID\n                doc_id = doc.id or str(uuid.uuid4())\n                ids.append(doc_id)\n                \n                # 文档内容\n                content = doc.content or \"\"\n                # 截断过长的内容\n                if len(content) > 60000:\n                    content = content[:60000] + \"...[截断]\"\n                contents.append(content)\n                \n                # 向量嵌入\n                if hasattr(doc, 'embedding') and doc.embedding is not None:\n                    embedding = doc.embedding\n                    if len(embedding) != self.vector_dimension:\n                        self.logger.warning(f\"文档 {doc_id} 的向量维度不匹配: {len(embedding)} != {self.vector_dimension}\")\n                        # 填充或截断向量\n                        if len(embedding) < self.vector_dimension:\n                            embedding.extend([0.0] * (self.vector_dimension - len(embedding)))\n                        else:\n                            embedding = embedding[:self.vector_dimension]\n                    embeddings.append(embedding)\n                else:\n                    # 如果没有嵌入，使用零向量\n                    self.logger.warning(f\"文档 {doc_id} 没有向量嵌入，使用零向量\")\n                    embeddings.append([0.0] * self.vector_dimension)\n                \n                # 元数据\n                metadata = doc.meta or {}\n                metadata_json = json.dumps(metadata, ensure_ascii=False)\n                # 截断过长的元数据\n                if len(metadata_json) > 60000:\n                    metadata_json = metadata_json[:60000] + \"...[截断]\"\n                metadatas.append(metadata_json)\n                \n                # 创建时间\n                created_ats.append(current_time)\n            \n            # 插入数据\n            data = [\n                ids,\n                contents,\n                embeddings,\n                metadatas,\n                created_ats\n            ]\n            \n            insert_result = self.collection.insert(data)\n            \n            # 刷新以确保数据持久化\n            self.collection.flush()\n            \n            self.logger.info(f\"成功添加 {len(documents)} 个文档到Milvus，插入ID数量: {len(insert_result.primary_keys)}\")\n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"添加文档到Milvus失败: {str(e)}\")\n            return False\n    \n    def search(self, query_embedding: List[float], top_k: int = 10, \n               filters: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:\n        \"\"\"\n        根据向量嵌入搜索相似文档\n        \n        Args:\n            query_embedding: 查询向量\n            top_k: 返回结果数量\n            filters: 过滤条件\n            \n        Returns:\n            搜索结果列表\n        \"\"\"\n        try:\n            # 验证查询向量维度\n            if len(query_embedding) != self.vector_dimension:\n                raise ValueError(f\"查询向量维度不匹配: {len(query_embedding)} != {self.vector_dimension}\")\n            \n            # 搜索参数\n            search_params = self.search_params.copy()\n            \n            # 构建过滤表达式\n            filter_expr = self._build_filter_expression(filters) if filters else None\n            \n            # 执行搜索\n            results = self.collection.search(\n                data=[query_embedding],\n                anns_field=\"embedding\",\n                param=search_params,\n                limit=top_k,\n                expr=filter_expr,\n                output_fields=[\"id\", \"content\", \"metadata\", \"created_at\"]\n            )\n            \n            # 处理搜索结果\n            formatted_results = []\n            \n            for hits in results:\n                for hit in hits:\n                    try:\n                        # 解析元数据\n                        metadata_str = hit.entity.get(\"metadata\", \"{}\")\n                        metadata = json.loads(metadata_str) if metadata_str else {}\n                    except json.JSONDecodeError:\n                        metadata = {}\n                    \n                    result = {\n                        \"id\": hit.entity.get(\"id\"),\n                        \"content\": hit.entity.get(\"content\", \"\"),\n                        \"score\": float(hit.score),\n                        \"metadata\": metadata,\n                        \"created_at\": hit.entity.get(\"created_at\")\n                    }\n                    \n                    formatted_results.append(result)\n            \n            self.logger.info(f\"搜索完成，返回 {len(formatted_results)} 个结果\")\n            return formatted_results\n            \n        except Exception as e:\n            self.logger.error(f\"搜索失败: {str(e)}\")\n            return []\n    \n    def get_document_by_id(self, doc_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        根据ID获取文档\n        \n        Args:\n            doc_id: 文档ID\n            \n        Returns:\n            文档信息或None\n        \"\"\"\n        try:\n            # 构建查询表达式\n            expr = f'id == \"{doc_id}\"'\n            \n            # 查询文档\n            results = self.collection.query(\n                expr=expr,\n                output_fields=[\"id\", \"content\", \"metadata\", \"created_at\"]\n            )\n            \n            if results:\n                result = results[0]\n                try:\n                    metadata = json.loads(result.get(\"metadata\", \"{}\"))\n                except json.JSONDecodeError:\n                    metadata = {}\n                \n                return {\n                    \"id\": result.get(\"id\"),\n                    \"content\": result.get(\"content\", \"\"),\n                    \"metadata\": metadata,\n                    \"created_at\": result.get(\"created_at\")\n                }\n            \n            return None\n            \n        except Exception as e:\n            self.logger.error(f\"根据ID获取文档失败: {str(e)}\")\n            return None\n    \n    def delete_documents(self, doc_ids: List[str]) -> bool:\n        \"\"\"\n        删除指定ID的文档\n        \n        Args:\n            doc_ids: 要删除的文档ID列表\n            \n        Returns:\n            是否删除成功\n        \"\"\"\n        try:\n            if not doc_ids:\n                return True\n            \n            # 构建删除表达式\n            ids_str = ', '.join([f'\"{doc_id}\"' for doc_id in doc_ids])\n            expr = f'id in [{ids_str}]'\n            \n            # 执行删除\n            delete_result = self.collection.delete(expr)\n            \n            # 刷新以确保删除操作持久化\n            self.collection.flush()\n            \n            self.logger.info(f\"成功删除 {len(doc_ids)} 个文档\")\n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"删除文档失败: {str(e)}\")\n            return False\n    \n    def get_document_count(self) -> int:\n        \"\"\"\n        获取集合中的文档总数\n        \n        Returns:\n            文档数量\n        \"\"\"\n        try:\n            # 刷新以获取最新统计信息\n            self.collection.flush()\n            \n            # 获取实体数量\n            count = self.collection.num_entities\n            \n            return count\n            \n        except Exception as e:\n            self.logger.error(f\"获取文档数量失败: {str(e)}\")\n            return 0\n    \n    def _build_filter_expression(self, filters: Dict[str, Any]) -> str:\n        \"\"\"\n        构建Milvus过滤表达式\n        \n        Args:\n            filters: 过滤条件字典\n            \n        Returns:\n            Milvus过滤表达式字符串\n        \"\"\"\n        expressions = []\n        \n        for key, value in filters.items():\n            if isinstance(value, str):\n                expressions.append(f'metadata like \"%{key}\":\\\"{value}\\\"%')\n            elif isinstance(value, (int, float)):\n                expressions.append(f'metadata like \"%{key}\":{value}%')\n            elif isinstance(value, list):\n                # 列表值使用IN操作\n                value_str = ', '.join([f'\"{v}\"' if isinstance(v, str) else str(v) for v in value])\n                expressions.append(f'metadata like \"%{key}\":[{value_str}]%')\n        \n        return ' and '.join(expressions) if expressions else \"\"\n    \n    def get_collection_info(self) -> Dict[str, Any]:\n        \"\"\"\n        获取集合信息\n        \n        Returns:\n            集合信息字典\n        \"\"\"\n        try:\n            info = {\n                \"collection_name\": self.collection_name,\n                \"document_count\": self.get_document_count(),\n                \"vector_dimension\": self.vector_dimension,\n                \"index_type\": self.index_type,\n                \"metric_type\": self.metric_type,\n                \"connection_info\": {\n                    \"host\": self.host,\n                    \"port\": self.port,\n                    \"database\": self.db_name,\n                    \"connected\": self.connected\n                }\n            }\n            \n            # 获取集合统计信息\n            if self.collection:\n                try:\n                    stats = self.collection.get_stats()\n                    info[\"collection_stats\"] = stats\n                except Exception:\n                    pass\n            \n            return info\n            \n        except Exception as e:\n            self.logger.error(f\"获取集合信息失败: {str(e)}\")\n            return {}\n    \n    def close(self) -> None:\n        \"\"\"关闭连接\"\"\"\n        try:\n            if self.collection:\n                self.collection = None\n            \n            if self.connected:\n                connections.disconnect(self.connection_alias)\n                self.connected = False\n            \n            self.logger.info(\"Milvus连接已关闭\")\n            \n        except Exception as e:\n            self.logger.error(f\"关闭Milvus连接失败: {str(e)}\")\n    \n    def __del__(self):\n        \"\"\"析构函数，确保连接被关闭\"\"\"\n        try:\n            self.close()\n        except Exception:\n            pass\n\n\n# 工厂函数\ndef create_milvus_store(config: Dict[str, Any]) -> MilvusDocumentStore:\n    \"\"\"\n    创建MilvusDocumentStore实例的工厂函数\n    \n    Args:\n        config: Milvus配置字典\n        \n    Returns:\n        MilvusDocumentStore实例\n    \"\"\"\n    return MilvusDocumentStore(config)"